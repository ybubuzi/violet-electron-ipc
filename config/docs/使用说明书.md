# Violet Electron IPC 框架使用说明书

## 📋 目录

1. [项目概述](#项目概述)
2. [核心特性](#核心特性)
3. [架构设计](#架构设计)
4. [快速开始](#快速开始)
5. [详细使用指南](#详细使用指南)
6. [高级特性](#高级特性)
7. [构建与部署](#构建与部署)
8. [最佳实践](#最佳实践)
9. [常见问题](#常见问题)

---

## 📖 项目概述

Violet Electron IPC 是一个功能强大且设计优雅的 Electron IPC（进程间通信）框架，旨在简化主进程与渲染器进程之间的通信。该框架利用现代 JavaScript 特性，提供无缝、类型安全且无需繁琐样板代码的开发体验。

### 核心价值

- **约定优于配置**：基于文件结构的自动 API 暴露机制
- **零样板代码**：无需手动注册 IPC 通道
- **类型安全**：完整的 TypeScript 支持
- **内存安全**：自动清理事件监听器，防止内存泄漏
- **上下文传播**：隐式的异步上下文管理

---

## ✨ 核心特性

### 1. 动态代理客户端
渲染器进程使用动态 `Proxy` 创建一个镜像主进程 API 的客户端，使您可以像调用本地方法一样调用主进程函数：

```typescript
// 像调用本地函数一样调用主进程 API
const result = await window.api.module.functionName()
```

### 2. 自动 API 注册
基于文件结构自动发现并暴露主进程 API，无需手动注册：

```
src/main/ipc/
├── greeter.ts          → api.greeter
├── message/
│   ├── index.ts        → api.message
│   └── shy-girl.ts     → api.message.shy
└── window/
    └── index.ts        → api.window
```

### 3. 隐式上下文传播
利用 Node.js 的 `AsyncLocalStorage`，`IpcMainInvokeEvent` 在 IPC 处理程序的整个调用堆栈中隐式可用：

```typescript
// 任何函数都能访问发送方的 BrowserWindow，而无需手动传递事件对象
export function maximize() {
  const event = getStore<IpcMainInvokeEvent>();
  const window = BrowserWindow.fromWebContents(event.sender);
  if (window) {
    window.maximize();
  }
}
```

### 4. 无内存泄漏的通知系统
发布/订阅系统使用 `WeakRef` 自动管理渲染器中事件监听器的生命周期：

```vue
<script setup>
onMounted(() => {
  // 监听器会自动绑定到组件的生命周期
  window.notify.addListener('download-complete', onDownloadUpdate);
});
// 组件销毁时，监听器自动被移除，无需手动清理
</script>
```

---

## 🏗️ 架构设计

### 核心架构图

```
┌─────────────────┐    IPC通信     ┌─────────────────┐
│   渲染器进程      │ ←----------→  │    主进程        │
│                │               │                │
│ ┌─────────────┐ │               │ ┌─────────────┐ │
│ │   代理客户端   │ │               │ │  API处理器   │ │
│ │   (Proxy)   │ │               │ │             │ │
│ └─────────────┘ │               │ └─────────────┘ │
│                │               │                │
│ ┌─────────────┐ │               │ ┌─────────────┐ │
│ │  通知监听器   │ │               │ │  通知发送器   │ │
│ │ (WeakRef)   │ │               │ │             │ │
│ └─────────────┘ │               │ └─────────────┘ │
└─────────────────┘               └─────────────────┘
```

### 目录结构

```
src/
├── main/
│   ├── ipc/                    # 主进程 API 模块
│   │   ├── index.ts           # 核心：扫描模块并设置 ipcMain.handle
│   │   ├── ctx.ts             # 核心：使用 AsyncLocalStorage 管理上下文
│   │   ├── handles.ts         # 聚合所有 API 模块
│   │   ├── message/           # 消息相关 API
│   │   ├── window/            # 窗口相关 API
│   │   ├── notify/            # 通知系统 API
│   │   └── store/             # 存储相关 API
│   ├── notify/                # 通知系统实现
│   │   └── index.ts           # 事件管理和分发
│   └── index.ts               # 主进程入口
│
├── preload/
│   └── index.ts               # 向渲染器暴露 IPC API
│
└── renderer/
    └── handle.ts              # 核心：渲染器的代理客户端实现
```

### 核心组件说明

#### 1. 主进程 IPC 处理器 (`src/main/ipc/index.ts`)

- **功能**：自动扫描 IPC 模块并注册处理器
- **核心机制**：深度递归遍历模块结构，支持嵌套命名空间
- **错误处理**：统一的错误包装和返回格式

```typescript
function deepIpcHandle(module: Object, prefix: string = '') {
  const memberList = Object.keys(module);
  for (const memberName of memberList) {
    const handle = '' === prefix ? memberName : `${prefix}-${memberName}`;
    const member = module[memberName];
    if (typeof member === 'function') {
      ipcMain.handle(handle, (event: IpcMainInvokeEvent, ...args: any[]) => {
        return run(event, async () => {
          // 统一的错误处理和结果包装
        });
      });
    }
    if (typeof member === 'object') {
      deepIpcHandle(member, handle); // 支持嵌套模块
    }
  }
}
```

#### 2. 上下文管理器 (`src/main/ipc/ctx.ts`)

- **功能**：使用 AsyncLocalStorage 管理异步上下文
- **用途**：在整个调用链中传递 IPC 事件对象
- **优势**：无需手动传递参数，任何深度函数都能访问上下文

```typescript
export function run(subject: unknown, callback: () => Promise<unknown>) {
  return new Promise((resolve, reject) => {
    asyncLocalStorage.run(subject, async () => {
      try {
        const result = await callback();
        resolve(result);
      } catch (error) {
        reject(error);
      }
    });
  });
}
```

#### 3. 渲染器代理客户端 (`src/renderer/handle.ts`)

- **功能**：创建动态代理，实现透明的 IPC 调用
- **特性**：支持链式调用和错误处理
- **通知系统**：基于 WeakRef 的自动内存管理

```typescript
const handle: ProxyHandler<ApiLike> = {
  get(target: ApiLike, name: string) {
    // 动态创建嵌套代理
    const parent = target.parent ? `${target.parent}-${name}` : name;
    async function executor() {}
    executor.parent = parent;
    return new Proxy(executor, handle);
  },
  apply(target: ApiLike, _thisArg, argumentsList: any[]) {
    // 执行 IPC 调用
    return window.electron.ipcRenderer.invoke(target.parent, ...argumentsList);
  }
};
```

#### 4. 通知系统 (`src/main/notify/index.ts`)

- **功能**：主进程向渲染器推送事件
- **特性**：支持多窗口、自动资源清理、生命周期管理
- **内存安全**：使用 WeakRef 防止内存泄漏

---

## 🚀 快速开始

### 环境要求

- Node.js: `^20.19.0 || >=22.12.0`
- Electron: `^21.0.0`
- TypeScript: `^5.8.3`

### 安装和运行

```bash
# 克隆项目
git clone <repository-url>
cd violet-electron-ipc

# 安装依赖
npm install

# 开发模式运行
npm run dev

# 构建应用
npm run build
```

### 创建第一个 API

#### 1. 创建主进程 API

创建文件 `src/main/ipc/greeter.ts`：

```typescript
// src/main/ipc/greeter.ts

export function sayHello(name: string): string {
  return `你好, ${name}! 这条消息来自主进程。`;
}

export function sayGoodbye(): string {
  return '再见!';
}

export async function asyncGreeting(name: string): Promise<string> {
  // 模拟异步操作
  await new Promise(resolve => setTimeout(resolve, 1000));
  return `异步问候: ${name}`;
}
```

#### 2. 在渲染器中调用 API

```vue
<!-- src/renderer/src/components/GreetingComponent.vue -->
<template>
  <div>
    <h2>{{ greeting }}</h2>
    <button @click="sayHello">问好</button>
    <button @click="sayGoodbye">告别</button>
    <button @click="asyncGreet">异步问候</button>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';

const greeting = ref('');

async function sayHello() {
  try {
    greeting.value = await window.api.greeter.sayHello('开发者');
  } catch (error) {
    console.error('调用失败:', error);
  }
}

async function sayGoodbye() {
  greeting.value = await window.api.greeter.sayGoodbye();
}

async function asyncGreet() {
  greeting.value = '正在处理中...';
  greeting.value = await window.api.greeter.asyncGreeting('用户');
}
</script>
```

---

## 📚 详细使用指南

### 主进程 API 开发

#### 1. 基础 API 定义

在 `src/main/ipc/` 目录下创建的任何 `.ts` 文件都会被自动发现并暴露给渲染器进程。

```typescript
// src/main/ipc/calculator.ts
export function add(a: number, b: number): number {
  return a + b;
}

export function multiply(a: number, b: number): number {
  return a * b;
}

export function divide(a: number, b: number): number {
  if (b === 0) {
    throw new Error('除数不能为零');
  }
  return a / b;
}
```

#### 2. 嵌套模块结构

支持嵌套的模块结构，创建更有组织的 API：

```
src/main/ipc/
├── database/
│   ├── index.ts          # 导出子模块
│   ├── users.ts          # 用户相关操作
│   └── products.ts       # 产品相关操作
└── file/
    ├── index.ts
    ├── read.ts           # 文件读取操作
    └── write.ts          # 文件写入操作
```

```typescript
// src/main/ipc/database/index.ts
export * as users from './users';
export * as products from './products';

// src/main/ipc/database/users.ts
export async function getUser(id: string) {
  // 数据库查询逻辑
  return { id, name: 'John Doe' };
}

export async function createUser(userData: any) {
  // 创建用户逻辑
  return { success: true, id: generateId() };
}
```

在渲染器中调用：

```typescript
// 调用嵌套 API
const user = await window.api.database.users.getUser('123');
const result = await window.api.database.products.createProduct(productData);
```

#### 3. 使用上下文信息

在主进程 API 中访问 IPC 上下文：

```typescript
// src/main/ipc/window.ts
import { BrowserWindow, IpcMainInvokeEvent } from 'electron';
import { getStore } from './ctx';

export function maximize() {
  const event = getStore<IpcMainInvokeEvent>();
  const window = BrowserWindow.fromWebContents(event.sender);
  if (window) {
    window.maximize();
  }
}

export function setTitle(title: string) {
  const event = getStore<IpcMainInvokeEvent>();
  const window = BrowserWindow.fromWebContents(event.sender);
  if (window) {
    window.setTitle(title);
  }
}

export function getBounds() {
  const event = getStore<IpcMainInvokeEvent>();
  const window = BrowserWindow.fromWebContents(event.sender);
  return window ? window.getBounds() : null;
}
```

### 渲染器 API 调用

#### 1. 基础调用模式

```typescript
// 直接调用
const result = await window.api.moduleName.functionName(arg1, arg2);

// 嵌套调用
const user = await window.api.database.users.getUser('123');
const settings = await window.api.app.settings.get();
```

#### 2. 错误处理

框架提供了统一的错误处理机制：

```typescript
try {
  const result = await window.api.someModule.riskyOperation();
  console.log('操作成功:', result);
} catch (error) {
  console.error('操作失败:', error.message);
  // 错误对象包含原始错误信息
  if (error.handle) {
    console.log('失败的处理器:', error.handle);
  }
}
```

#### 3. TypeScript 支持

为了获得完整的 TypeScript 支持，可以创建类型声明文件：

```typescript
// src/renderer/types/api.d.ts
interface Window {
  api: {
    greeter: {
      sayHello(name: string): Promise<string>;
      sayGoodbye(): Promise<string>;
      asyncGreeting(name: string): Promise<string>;
    };
    calculator: {
      add(a: number, b: number): Promise<number>;
      multiply(a: number, b: number): Promise<number>;
      divide(a: number, b: number): Promise<number>;
    };
    database: {
      users: {
        getUser(id: string): Promise<User>;
        createUser(userData: CreateUserRequest): Promise<CreateUserResponse>;
      };
    };
  };
  notify: {
    addListener(event: string, callback: Function): void;
    removeListener(event: string, callback: Function): void;
    removeAllListeners(event: string): void;
  };
}
```

### 通知系统使用

#### 1. 主进程发送通知

```typescript
// 在主进程的任何地方发送通知
import { sendToWebContent } from '@/main/notify';

// 向所有监听窗口发送通知
sendToWebContent('user-login', { userId: '123', username: 'John' });
sendToWebContent('download-progress', { progress: 75, total: 100 });
sendToWebContent('app-update-available', { version: '1.2.0' });
```

#### 2. 渲染器监听通知

```vue
<!-- Vue 3 组件示例 -->
<template>
  <div>
    <p>登录状态: {{ loginStatus }}</p>
    <p>下载进度: {{ downloadProgress }}%</p>
    <div class="progress-bar">
      <div class="progress-fill" :style="{ width: downloadProgress + '%' }"></div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';

const loginStatus = ref('未登录');
const downloadProgress = ref(0);

function onUserLogin(data: { userId: string, username: string }) {
  loginStatus.value = `已登录: ${data.username}`;
  console.log('用户登录事件:', data);
}

function onDownloadProgress(data: { progress: number, total: number }) {
  downloadProgress.value = data.progress;
  console.log('下载进度:', data);
}

onMounted(() => {
  // 自动绑定的监听器，组件销毁时自动清理
  window.notify.addListener('user-login', onUserLogin);
  window.notify.addListener('download-progress', onDownloadProgress);
});
</script>
```

#### 3. 手动管理监听器

虽然框架提供了自动清理机制，但在某些场景下可能需要手动管理：

```typescript
// 添加监听器
function handleNotification(data: any) {
  console.log('收到通知:', data);
}

window.notify.addListener('my-event', handleNotification);

// 手动移除监听器
window.notify.removeListener('my-event', handleNotification);

// 移除事件的所有监听器
window.notify.removeAllListeners('my-event');
```

---

## 🔧 高级特性

### 数据持久化

框架内置了简单的键值对存储功能：

```typescript
// src/main/ipc/store/index.ts
export function get<T>(key: string, defaultValue?: T): T {
  return AppStore.getInstance().get(key, defaultValue);
}

export function set<T>(key: string, newValue?: T): void {
  const oldValue = get(key);
  let mergeValue = newValue;
  if (typeof oldValue === 'object') {
    mergeValue = { ...oldValue, ...newValue };
  }
  return AppStore.getInstance().set(key, mergeValue);
}
```

使用示例：

```typescript
// 设置配置
await window.api.store.set('app.theme', 'dark');
await window.api.store.set('user.preferences', {
  language: 'zh-CN',
  autoSave: true
});

// 获取配置
const theme = await window.api.store.get('app.theme', 'light');
const preferences = await window.api.store.get('user.preferences', {});
```

### 异步操作和错误处理

#### 1. 异步 API 定义

```typescript
// src/main/ipc/file.ts
import fs from 'fs/promises';
import path from 'path';

export async function readFile(filePath: string): Promise<string> {
  try {
    const content = await fs.readFile(filePath, 'utf-8');
    return content;
  } catch (error) {
    throw new Error(`读取文件失败: ${error.message}`);
  }
}

export async function writeFile(filePath: string, content: string): Promise<void> {
  try {
    const dir = path.dirname(filePath);
    await fs.mkdir(dir, { recursive: true });
    await fs.writeFile(filePath, content, 'utf-8');
  } catch (error) {
    throw new Error(`写入文件失败: ${error.message}`);
  }
}
```

#### 2. 渲染器中的异步处理

```typescript
// 优雅的异步错误处理
async function handleFileOperation() {
  try {
    const content = await window.api.file.readFile('/path/to/file.txt');
    console.log('文件内容:', content);

    await window.api.file.writeFile('/path/to/output.txt', content);
    console.log('文件写入成功');
  } catch (error) {
    console.error('文件操作失败:', error.message);
    // 可以根据错误类型进行不同的处理
    if (error.message.includes('ENOENT')) {
      console.log('文件不存在，请检查路径');
    }
  }
}
```

### 类型安全的 API 调用

#### 1. 创建共享类型定义

```typescript
// src/shared/types.ts
export interface User {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
}

export interface CreateUserRequest {
  name: string;
  email: string;
}

export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}
```

#### 2. 在主进程中使用类型

```typescript
// src/main/ipc/users.ts
import type { User, CreateUserRequest, ApiResponse } from '@/shared/types';

export async function createUser(request: CreateUserRequest): Promise<ApiResponse<User>> {
  try {
    // 验证输入
    if (!request.name || !request.email) {
      return {
        success: false,
        error: '姓名和邮箱不能为空'
      };
    }

    // 创建用户逻辑
    const user: User = {
      id: generateId(),
      name: request.name,
      email: request.email,
      createdAt: new Date()
    };

    // 保存到数据库
    await saveUserToDatabase(user);

    return {
      success: true,
      data: user
    };
  } catch (error) {
    return {
      success: false,
      error: error.message
    };
  }
}
```

#### 3. 在渲染器中使用类型

```typescript
// src/renderer/src/services/userService.ts
import type { User, CreateUserRequest, ApiResponse } from '@/shared/types';

class UserService {
  async createUser(request: CreateUserRequest): Promise<User> {
    const response: ApiResponse<User> = await window.api.users.createUser(request);

    if (!response.success) {
      throw new Error(response.error || '创建用户失败');
    }

    return response.data!;
  }

  async getUserById(id: string): Promise<User> {
    const response: ApiResponse<User> = await window.api.users.getUserById(id);

    if (!response.success) {
      throw new Error(response.error || '获取用户失败');
    }

    return response.data!;
  }
}

export const userService = new UserService();
```

---

## 🏗️ 构建与部署

### 标准构建

```bash
# 类型检查和构建
npm run build

# 构建不同平台
npm run build:win      # Windows
npm run build:mac      # macOS
npm run build:linux    # Linux

# 开发构建（不打包）
npm run build:unpack
```

### 优化构建：分离 node_modules

为了提升性能并实现更高效的更新，项目支持将最终打包的应用程序拆分为两个独立的 `asar` 归档文件：

#### 优势

1. **更快的启动速度**：Electron 可以更快地加载较小的 `app.asar`
2. **高效的更新**：用户通常只需要下载已更改的 `app.asar`

#### 构建命令

```bash
# 创建启用 asar 拆分的构建
npm run build:tiny:win
```

#### 构建流程说明

1. **`config/electron-build/split-asar-builder.mjs`**：自定义构建入口点
2. **`config/electron-build/split-asar-builder-handle.cjs`**：分离 `node_modules` 到 `deps.asar`
3. **`config/vite-plugin/split-deps-loader.vite.config.ts`**：注入加载器脚本
4. **`config/electron-build/split-asar-builder-dep-loader.cjs`**：运行时依赖加载器

构建完成后，`out/` 目录中将包含：
- `resources/app.asar`：应用程序源代码
- `resources/deps.asar`：依赖项

---

## 💡 最佳实践

### 1. API 设计原则

#### 单一职责
每个 API 函数应该只负责一个明确的功能：

```typescript
// ✅ 好的设计
export function getUser(id: string): Promise<User> { }
export function updateUser(id: string, data: Partial<User>): Promise<User> { }
export function deleteUser(id: string): Promise<void> { }

// ❌ 避免这样设计
export async function manageUser(action: string, id: string, data?: any): Promise<any> { }
```

#### 输入验证
在主进程中始终验证输入参数：

```typescript
export function createUser(userData: { name: string, email: string }): Promise<User> {
  if (!userData.name || userData.name.trim().length === 0) {
    throw new Error('用户名不能为空');
  }

  if (!userData.email || !isValidEmail(userData.email)) {
    throw new Error('邮箱格式无效');
  }

  // 继续处理...
}
```

#### 错误处理
提供有意义的错误信息：

```typescript
export async function readFile(filePath: string): Promise<string> {
  try {
    return await fs.readFile(filePath, 'utf-8');
  } catch (error) {
    if (error.code === 'ENOENT') {
      throw new Error(`文件不存在: ${filePath}`);
    } else if (error.code === 'EACCES') {
      throw new Error(`没有权限读取文件: ${filePath}`);
    } else {
      throw new Error(`读取文件失败: ${error.message}`);
    }
  }
}
```

### 2. 模块组织

#### 按功能分组
将相关的 API 组织到同一个模块中：

```
src/main/ipc/
├── auth/
│   ├── index.ts
│   ├── login.ts
│   ├── register.ts
│   └── logout.ts
├── database/
│   ├── index.ts
│   ├── users.ts
│   ├── products.ts
│   └── orders.ts
├── file/
│   ├── index.ts
│   ├── read.ts
│   ├── write.ts
│   └── metadata.ts
└── system/
    ├── index.ts
    ├── info.ts
    └── settings.ts
```

#### 使用 barrel exports
在 `index.ts` 文件中导出模块内容：

```typescript
// src/main/ipc/auth/index.ts
export * as login from './login';
export * as register from './register';
export * as logout from './logout';

// src/main/ipc/handles.ts
export * as auth from './auth';
export * as database from './database';
export * as file from './file';
export * as system from './system';
```

### 3. 性能优化

#### 避免频繁的 IPC 调用
批量处理多个操作：

```typescript
// ❌ 避免多次调用
for (const item of items) {
  await window.api.database.saveItem(item);
}

// ✅ 批量处理
await window.api.database.saveItems(items);
```

#### 缓存结果
在渲染器中缓存频繁访问的数据：

```typescript
class ConfigService {
  private cache: Map<string, any> = new Map();

  async getConfig(key: string): Promise<any> {
    if (this.cache.has(key)) {
      return this.cache.get(key);
    }

    const value = await window.api.config.get(key);
    this.cache.set(key, value);
    return value;
  }

  invalidateCache(key?: string) {
    if (key) {
      this.cache.delete(key);
    } else {
      this.cache.clear();
    }
  }
}
```

#### 使用流式处理
对于大量数据，使用流式处理：

```typescript
// 主进程
export async function exportLargeData(): Promise<string> {
  const stream = fs.createReadStream('/path/to/large/file.json');
  // 流式处理逻辑
  return streamPath;
}

// 渲染器
const filePath = await window.api.data.exportLargeData();
// 分块读取和处理
```

### 4. 安全考虑

#### 输入清理
始终清理和验证来自渲染器的输入：

```typescript
import path from 'path';

export function readFile(filePath: string): Promise<string> {
  // 防止路径遍历攻击
  const normalizedPath = path.normalize(filePath);
  if (normalizedPath.includes('..')) {
    throw new Error('不允许的路径');
  }

  // 确保路径在允许的目录内
  const allowedDir = path.resolve('/app/data');
  const fullPath = path.resolve(allowedDir, normalizedPath);

  if (!fullPath.startsWith(allowedDir)) {
    throw new Error('访问被拒绝');
  }

  return fs.readFile(fullPath, 'utf-8');
}
```

#### 权限检查
使用上下文信息进行权限检查：

```typescript
export function deleteFile(filePath: string): Promise<void> {
  const event = getStore<IpcMainInvokeEvent>();
  const window = BrowserWindow.fromWebContents(event.sender);

  // 检查窗口是否有权限执行此操作
  if (!hasPermission(window, 'file.delete')) {
    throw new Error('没有删除文件的权限');
  }

  // 继续处理...
}
```

### 5. 测试策略

#### 单元测试
为主进程 API 编写单元测试：

```typescript
// tests/main/ipc/calculator.test.ts
import { describe, it, expect } from 'vitest';
import { add, multiply, divide } from '@/main/ipc/calculator';

describe('Calculator API', () => {
  it('should add two numbers', () => {
    expect(add(2, 3)).toBe(5);
  });

  it('should multiply two numbers', () => {
    expect(multiply(2, 3)).toBe(6);
  });

  it('should throw error when dividing by zero', () => {
    expect(() => divide(10, 0)).toThrow('除数不能为零');
  });
});
```

#### 集成测试
测试 IPC 通信：

```typescript
// tests/integration/ipc.test.ts
import { app, BrowserWindow } from 'electron';
import { callMainProcessApi } from '../helpers/electron';

describe('IPC Integration', () => {
  let window: BrowserWindow;

  beforeAll(async () => {
    await app.whenReady();
    window = new BrowserWindow({
      show: false,
      webPreferences: {
        nodeIntegration: true,
        contextIsolation: false
      }
    });
  });

  it('should call calculator API', async () => {
    const result = await window.webContents.executeJavaScript(`
      window.api.calculator.add(5, 3)
    `);

    expect(result).toBe(8);
  });
});
```

---

## ❓ 常见问题

### Q1: 如何调试 IPC 通信？

**A**: 在开发过程中，可以通过以下方式调试：

```typescript
// 主进程中添加日志
ipcMain.handle('my-api', (event, ...args) => {
  console.log('API 调用:', event.sender.id, args);
  // 处理逻辑...
});

// 渲染器中添加日志
const result = await window.api.myModule.myFunction(args);
console.log('API 结果:', result);
```

### Q2: 如何处理大文件传输？

**A**: 对于大文件，建议使用流式处理或文件路径传递：

```typescript
// 主进程
export function getFilePath(filename: string): Promise<string> {
  return path.join('/app/data', filename);
}

// 渲染器
const filePath = await window.api.file.getFilePath('large-file.pdf');
// 使用 fetch 或其他方式读取文件
```

### Q3: 如何实现实时数据同步？

**A**: 使用通知系统结合定时器：

```typescript
// 主进程 - 定期发送更新
setInterval(() => {
  const data = getLatestData();
  sendToWebContent('data-update', data);
}, 1000);

// 渲染器 - 监听更新
onMounted(() => {
  window.notify.addListener('data-update', (data) => {
    updateLocalData(data);
  });
});
```

### Q4: 如何处理并发请求？

**A**: 框架自动处理并发请求，但需要注意资源竞争：

```typescript
// 主进程 - 使用互斥锁
const lockMap = new Map<string, Promise<any>>();

export async function updateResource(id: string, data: any): Promise<void> {
  if (lockMap.has(id)) {
    await lockMap.get(id);
  }

  const updatePromise = performUpdate(id, data);
  lockMap.set(id, updatePromise);

  try {
    await updatePromise;
  } finally {
    lockMap.delete(id);
  }
}
```

### Q5: 如何实现 API 版本控制？

**A**: 使用命名空间或前缀：

```typescript
// src/main/ipc/v1/users.ts
export async function getUser(id: string): Promise<User> { }

// src/main/ipc/v2/users.ts
export async function getUser(id: string): Promise<UserV2> { }

// src/main/ipc/handles.ts
export * as v1 from './v1';
export * as v2 from './v2';
```

调用时：`window.api.v1.users.getUser()` 或 `window.api.v2.users.getUser()`

### Q6: 如何处理内存泄漏？

**A**: 框架已经提供了自动内存管理，但仍建议：

1. **及时清理资源**：对于长时间运行的操作，确保正确清理
2. **避免闭包陷阱**：在事件监听器中避免不必要的闭包
3. **定期检查**：使用 Chrome DevTools 的 Memory 面板检查内存使用

```typescript
// ✅ 正确的做法
onMounted(() => {
  const handler = (data) => processData(data);
  window.notify.addListener('event', handler);

  // 框架会自动清理，但也可以手动清理
  onUnmounted(() => {
    window.notify.removeListener('event', handler);
  });
});
```

### Q7: 如何实现 API 超时控制？

**A**: 在渲染器中实现超时包装：

```typescript
async function callWithTimeout<T>(apiCall: Promise<T>, timeout: number): Promise<T> {
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => reject(new Error('API 调用超时')), timeout);
  });

  return Promise.race([apiCall, timeoutPromise]);
}

// 使用
try {
  const result = await callWithTimeout(
    window.api.slowOperation.data(),
    5000 // 5秒超时
  );
} catch (error) {
  if (error.message === 'API 调用超时') {
    console.log('操作超时，请重试');
  }
}
```

---

## 📝 总结

Violet Electron IPC 框架提供了一个优雅、高效且安全的解决方案，用于处理 Electron 应用中的进程间通信。通过其创新的代理机制、自动上下文传播和内存安全的通知系统，开发者可以专注于业务逻辑而无需处理繁琐的 IPC 样板代码。

### 关键优势回顾

- **零配置**：基于文件结构的自动 API 发现
- **类型安全**：完整的 TypeScript 支持
- **内存安全**：自动清理的事件监听器
- **上下文感知**：隐式的异步上下文传播
- **高性能**：优化的构建和部署策略

### 适用场景

该框架特别适合：
- 需要复杂进程间通信的 Electron 应用
- 要求类型安全的项目
- 关注内存管理的长期运行应用
- 需要快速原型开发的项目

通过遵循本指南的最佳实践，您可以构建出高质量、可维护的 Electron 应用。